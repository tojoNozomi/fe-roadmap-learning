# RX.js学习

### 基础概念

> ReactiveX，也就是RX的全称。早在1997年的时候，就有人提出FRP（Function Reactive Programming）也就是函数响应式编程。这是一种编程范式，同时具有函数式和响应式的特点。
>
> 响应式，也就是等待外界输入，然后进行处理。而函数式则是讲究一个无副作用，不会影响外界。
>
> 而ReactiveX则在2012年由微软.NET开发组提出，后续也有不同的语言实现版本涌现。

RxJS是一个强大的Reactive编程库，提供了强大的数据流组合与控制能力，适合在交互复杂场景下使用。

在使用RxJS时，可以把一切输入都当作数据流来处理，如

* 用户输入
* 网络响应
* 定时器
* Worker

实际上RxJS这些数据流严格来讲应该可以说是管道了，RxJS中由这么些东西：

* Observable：可观察对象，数据只出不进
* Observer： 观察者，数据只进不出
* Subject： 主体对象，可进可出，可作为观察者
* ReplaySubject： 带回放的
* Subscription： 订阅关系

前三种可以说是描述管道的形状，流向。而subscription则是订阅之后形成的订阅关系，可以用来取消订阅。



### 异步的困境

最开始的异步，那就是回调。不过显而易见的就是回调在复杂的逻辑中很乏力，江湖人称“回调地狱”。

后来有了Promise，不过使用场景上有些限制，比如Promise都是即时执行的，而且是不可取消的，另外只能承载一个值，在处理集合或者数量未知的数据时会比较困难。



### ReactiveX的一些概念

* creator： 创建器，用于将现有数据转换成Observable对象



### 宝石图（弹珠图）

* 带箭头的线： 用于表示数据序列的“流”
* 圆圈： 数据项
* 最后面圆圈之后的竖线或者叉号：竖线表示正常终止，叉号表示这个流抛出错误而异常终止了
* 没有叉号和竖线的流： 也就是“无尽流”，不会主动终止的流，一直等待数据，有就处理
* 中间的大方框：operator，一般是一个函数，输入经过这个函数而变成输出



### RX.js的一些API

如下是简单的一种写法：

```javascript
of(1,2,3).pipe(

filter(item=>item % 2 === 1),

map(item=>item * 3),

).subscribe(item=> console.log(item))
```

of用来创建一个Observable对象，然后pipe中两个方法是operator，用来依次对数据进行处理。

而subscribe则表示消费者要去订阅这个Observable对象，不使用subscribe方法的话就不会执行pipe里面的operator。每一个数据会触发一次subscribe中的回调函数。



##### 创建器方法

* of： 单一值转换成流（参数可以传入一到多个单一值）
* from： 数组转换成流
* range： 范围转换为流 （传入两个数字，表示范围）
* fromPromise： Promise转换为流（传入时就调用了）
* defer： 惰性创建流，在只有消费者需要的时候才执行（传入函数）
* timer：定时器流，产生一个无尽流（传入两个参数，第一个指首次等待的时间，第二个参数指间隔时间）
* interval： 定时器流（相当于两个参数都是相等的timer创建器）



##### Subject 主体对象



##### 合并创建器

* merge 类似于并联，只要任意一个流有值了就会立刻被输出
* concat 类似于串联，需要两个流都不是无尽流，前面的流没有结束，后面的流就不会开始
* zip 像拉链一样，需要两个流中的数据合并（有对应关系的，就是取到其中一个流的数据，要等到另外一个流的数据到了才进行操作）



##### 操作符

常见的有如`map / reduce / filter`等函数式编程的常用方法。

一些不太常见的有：

* retry：失败时重试
* repeat：成功时重试
* delay： 延迟
* toArray： 收集为数组
* debounceTime： 防抖
* swtichMap： 将一个流转换成另外一个流

##### 有套路的操作符

* xxxWhen： 满足xxx条件时
* xxxCount：拿到n个数据项时xxx
* xxxTime： 超时后xxx
* xxxTo： 用字面量代替Lambda表达式



### 最佳实践

##### 取消订阅

一般来讲，不是无尽流的流在完成后会自动取消订阅并释放相关内存的。而对于一些场景中无尽流的订阅不是时刻都需要的，那么就需要在不再用的时候取消这部分订阅。

Observable对象在调用了subscribe方法之后会返回一个Subscription类型的引用。这实际上也是一个订阅凭证。将这个引用保存起来，可以在不再订阅的时候调用unsubscribe方法进行取消订阅。

##### 类型检查

RxJS程序会涉及到很多数据，大量operator操作会频繁改变流中的数据类型，靠人工进行类型追踪确实是太累了，使用TypeScript的话可以比较合理、高效地完成类型检查的任务。

##### 代码风格

ReactiveX的代码要和FP一样，由一系列小的，单一职责的，无副作用的函数组成。在编程的过程中要遵循无副作用和数据不变性。



### 使用场景

##### 定时器

当很多地方需要用到定时器的时候（同样时间间隔），每个地方都写一个定时器也太浪费资源了。可以将定时器写成一个服务，把需要周期性执行的业务都放上去，当成定时任务。



##### 时间轴操作

RxJS以流的方式去处理数据，因此可以使用不同的操作符来对流上的数据进行延时、取样、调整数据密度等	



##### 数据的回放

RxJS还提供了`BehaviourSubject`和`ReplaySubject`，用来记录数据流上一些比较重要的数据，而且这些数据可以被订阅。

