# 浏览器相关知识点

### 浏览器

主要组成部分：

* 用户界面： 地址栏、返回、书签等控件
* 数据持久化： cookie、 localstorage
* 浏览器引擎： 平台应用相关结构，承担UI和渲染引擎的交互、控制
* 渲染引擎： HTML和CSS解析和渲染
* JS引擎（解释器）： 解析、执行JS代码
* 用户界面后端： 图形库
* 网络： 调用网络，如HTTP请求

其中浏览器内核包括渲染引擎和JS引擎两部分。

### 浏览器渲染机制

##### 过程

> 1. HTML和CSS经过各自的解析器，（词法、语法分析，转成AST树）转换成DOM树和CSSOM树
> 2. 合并为渲染树
> 3. 根据渲染树进行布局
> 4. 调用GPU进行绘制，然后显示到屏幕上

<img src="./pic/broswer-1.png" alt="render processing" style="zoom:30%;" />

##### 优化首屏加载速度

**优化文件大小**： HTML和CSS的加载和解析会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度



**避免资源下载阻塞文档解析**：浏览器解析到<script>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把<script>标签放在底部，或者加上`defer、async`来进行异步下载

##### 回流（重排）的概念

当元素的尺寸或者位置发生变化时，需要重新计算渲染树，也就是回流

触发回流的因素：

* DOM元素的几何属性： width / height / padding / margin / border
* DOM元素的移动或者增加
* 读写 offset / scroll / client 等属性时
* 调用`window.getComputedStyle`



##### 重绘的概念

DOM样式发生变化而没影响DOM的几何属性时，会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流



##### GPU加速

使用transform opacity filters等属性时，GPU可以直接完成处理，这些处理不会导致回流和重绘。不过有个缺点就是GPU渲染等字体会模糊，过多的GPU处理有内存问题。



##### 优化： 减少回流、重绘

* 使用class 替代style，减少style的使用
* resize、scroll操作时，使用防抖和节流处理，这两者会直接导致回流
* 使用visibility替代display: none，前者只会触发重绘，后者会触发回流
* 批量修改元素时，可以使元素先脱离文档流，修改后再放入。
* 复杂动画效果，使用绝对定位，脱离文档流。复杂的动画会频繁触发回流/重绘，脱离文档流后可以避免这个问题。



### 浏览器缓存策略

##### 浏览器缓存位置以及优先级

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache
5. 没有命中则进行网络请求

上述缓存中，Service Worker和Web Worker比较类似，是一个独立的线程，可以在这个线程中缓存文件，并在主线程需要的时候读取这些文件。使用SW可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的。

而内存缓存则是不连续性的，缓存会随着进程释放而释放。

硬盘缓存相比于内存缓存，其持续性和容量更好，它会根据HTTP 头部信息判断哪些资源需要缓存。

推送缓存，是HTTP/2的内容，目前应用比较少。

##### 缓存策略

强缓存：

1. 设置Expires。也就是设置过期时间，表示缓存会在这个时间之后失效。不过存在一个问题就是这个时间是以本地时间为准，如果本地时间和服务器时间存在差异的话可能导致缓存失效。

2. 设置Cache-Control。可以通过max-age字段来设置过期时间。比如`Cache-Control: max-age=3600`，也可以设置为`no-cache / no-store / public / private `等值

   > no-cache：每次访问前询问服务器
   >
   > no-store： 禁止使用缓存
   >
   > public：允许CDN和浏览器进行缓存
   >
   > private ： 只允许浏览器缓存

3. Last-Modified。最后修改时间。浏览器第一次请求资源时，服务器会在响应头加上这个字段。当浏览器再次请求这个资源时，会在请求头带上`If-Modified_Since`字段，值为前面服务器返回的最后修改时间。服务器会对比这两个时间，如果一致则返回304，否则返回新的资源，并更新Last-Modified值

4. Etag。HTTP/1.1新增字段，表示文件唯一标识。Etag类似于content hash，只要文件内容变动了，值就会改变。缓存流程同Last-Modified：第一次请求，响应头带Etag字段 --- 再次请求时浏览器发送If-None-Match --- 如果不匹配，返回新资源并更新Etag，否则返回304

Etag和Last-Modified相比，更为准确。Last-Modified的计时单位为秒，当两次修改完成的时间间隔小于一秒时，Last-Modified的值和之前一样。

另外，如果没有设置任何缓存策略，那么浏览器会自动取响应头带Date减去Last-Modified值的10%作为缓存时间。